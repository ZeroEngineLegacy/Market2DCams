/********************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved          */
/* Last Update: 12/13/2016                              */
/********************************************************/


class MultiFocusCamera2D : ZilchComponent
{
    [Dependency]
    var Transform : Transform;
    
    [Dependency]
    var Camera : Camera;
    
    [Dependency]
    var CameraViewport : CameraViewport;
    
    [Dependency]
    var Orientation : Orientation;
    
    // Should the component be active?
    [Property]
    var Active : Boolean = true;
    
    // Speed at which the camera object moves
    [Property]
    var TrackingSpeed : Real = 5.0;
    
    // Should tracking be based of the average position of all objects, or the average position of the 4 axis extrema objects
    [Property]
    var ExtremaBasedTracking : Boolean = false;
    
    // Should the weights of the focus objects be used in tracking calculations
    // Requires ExtremaBaseFocusing not to be active
    [Property]
    var WeightedTracking : Boolean = true;
    
    // Speed at which the camera focus point moves
    [Property]
    var FocusSpeed : Real = 10.0;
    
    // Should the camera focus on the average position of all objects or the average position of the 4 axis extrema objects
    // True = Average of extreme positions
    // False  = Average all positions
    [Property]
    var ExtremaBaseFocusing : Boolean = true;
    
    // Should the weights of the focus objects be used in focus calculations
    // Requires ExtremaBaseFocusing not to be active
    [Property]
    var WeightedFocusing : Boolean = true;
    
    // Minimum Z axis depth of the camera
    [Property]
    var MinZoom : Real = 1.0;
    
    // Maximum Z axis depth of the camera
    [Property]
    var MaxZoom : Real = 100.0;
    
    // Size of the gap between an axis extrema object and its corresponding screenedge
    [Property]
    var ScreenPadding : Real2 = Real2();
    
    // Maximum number of object allowed on the focus list
    [Property]
    var MaxObjectCount : Integer = 10;
    
    // Current focus point for the camera
    var FocusPos : Real3 = Real3();
    
    // List of all object's that should be focused in the camera view
    var FocusList : Array[Cog] = null;
    
    //Sum of weights of all focused objects
    var TotalWeight : Real = 0;
    
    // Turns console debug output on/off
    [Property]
    var DebugPrint : Boolean = false;
    
    //On error should an exception be thrown to stop the application
    [Property]
    var BreakOnError : Boolean = true;
    
    sends CameraFocusEvent : CameraFocusEvent;
    sends CameraUnfocusEvent : CameraUnfocusEvent;
    
    function Initialize(init : CogInitializer)
    {
        //Align FocusPos with the camera on the 0.0 Z-Axis to center camera intially
        this.FocusPos = this.Owner.Transform.WorldTranslation;
        this.FocusPos.Z = 0.0;
        
        // Construct the focus object and focus object weight list
        this.FocusList = Array[Cog]();
        
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(this.Space, Events.CameraFocusEvent, this.OnFocusCamera);
        Zero.Connect(this.Space, Events.CameraUnfocusEvent, this.OnUnfocusCamera);
    }
    
    function OnLogicUpdate(event : UpdateEvent)
    {
        // If the component is not active do nothing
        // If there are no object's to focus on do nothing
        if(!this.Active || this.FocusList.Count == 0)
            return;
        
        // Create variables to keep track of the objects that have the most extreme positive and negative positions on the X & Y axis
        var topMost : Cog = null;
        var botMost : Cog = null;
        var leftMost : Cog = null;
        var rightMost : Cog = null;
        
        // Will store the average position of every focus object
        var avePos : Real3 = Real3();
        // Will store the weighted average position of every focus object
        var avePosWeighted : Real3 = Real3();
        
        // Loop through the focus objects to compare for teh axis extrema and the average positions
        for(var i : Integer = 0; i < this.FocusList.Count; i += 1)
        {
            // Get the object and weight of the current index
            var obj : Cog = this.FocusList.Get(i);
            var weight : Real = obj.CameraFocusTarget.FocusWeight;
            
            // Cache the object's scale
            var objPos : Real3 = obj.Transform.WorldTranslation;
            var objScale : Real3 = obj.Transform.WorldScale;
            
            // Check to see if the object's Y cord is greater than the topMost object (if topMost is null just make this the the topMost for future passes)
            if(topMost == null || objPos.Y + (objScale.Y / 2.0) > topMost.Transform.WorldTranslation.Y + (topMost.Transform.WorldScale.Y / 2.0))
            {
                topMost = obj;
            }
            // Check to see if the object's Y cord is less than the botMost object (if botMost is null just make this the the botMost for future passes)
            if(botMost == null || objPos.Y - (objScale.Y / 2.0) < botMost.Transform.WorldTranslation.Y - (botMost.Transform.WorldScale.Y / 2.0))
            {
                botMost = obj;
            }
            // Check to see if the object's X cord is less than the leftMost object (if leftMost is null just make this the the leftMost for future passes)
            if(leftMost == null || objPos.X - (objScale.X / 2.0) < leftMost.Transform.WorldTranslation.X - (leftMost.Transform.WorldScale.X / 2.0))
            {
                leftMost = obj;
            }
            // Check to see if the object's X cord is greater than the rightMost object (if rightMost is null just make this the the rightMost for future passes)
            if(rightMost == null || objPos.X + (objScale.X / 2.0) > rightMost.Transform.WorldTranslation.X + (rightMost.Transform.WorldScale.X / 2.0))
            {
                rightMost = obj;
            }
            
            // Collect the position of all focus objects
            avePos += obj.Transform.WorldTranslation;
            // Collect the weighted position of all focus objects
            avePosWeighted += obj.Transform.WorldTranslation * weight;
        }
        
        this.DebugOutput("TopMost: `topMost`");
        this.DebugOutput("botMost: `botMost`");
        this.DebugOutput("leftMost: `leftMost`");
        this.DebugOutput("rightMost: `rightMost`");
        
        // Finish calculating the average position of all focus objects
        avePos /= this.FocusList.Count;
        
        // Finish calculating the weighted average position of all focus objects
        if(this.WeightedTracking)
            avePosWeighted /= this.TotalWeight;
        
        // Use the X cord and scale of the left and right most object's to calculate the minimum width of the view plane in world space for both object to be visible on screen
        var minWidth = rightMost.Transform.WorldTranslation.X + (rightMost.Transform.WorldScale.X / 2.0) - leftMost.Transform.WorldTranslation.X - (leftMost.Transform.WorldScale.X / 2.0);
        this.DebugOutput("MinWidth: `minWidth`");
        
        // Use the Y cord and scale of the top and bot most object's to calculate the minimum height of the view plane in world space for both object to be visible on screen
        var minHeight = topMost.Transform.WorldTranslation.Y + (topMost.Transform.WorldScale.Y / 2.0) - botMost.Transform.WorldTranslation.Y - (botMost.Transform.WorldScale.Y / 2.0);
        this.DebugOutput("minHeight: `minHeight`");
        
        // Get the aspect ratio of the viewport
        var viewportRes = this.CameraViewport.ViewportResolutionWithMargin;
        var aspectRatio : Real = 0.0;
        
        if (viewportRes.Y == 0.0)
        {
          aspectRatio = 1.0;
        }
        else
        {
          aspectRatio = viewportRes.X / viewportRes.Y;
        }
        
        this.DebugOutput("viewportWidth: `viewportRes.X`");
        this.DebugOutput("viewportHeight: `viewportRes.Y`");
        
        // Add the edge gaps for each edge into the minHeight and minWidth before aspect ratio correction
        minWidth += this.ScreenPadding.X * 2.0;
        minHeight += this.ScreenPadding.Y * 2.0;
        
        var minAspect : Real = 0;
        
        if (minHeight == 0.0)
        {
          minAspect = 1.0;
        }
        else
        {
          minAspect = minWidth / minHeight;
        }
        
        // Determine if the height or width of the required aspect ratio is bigger
        if (minAspect > aspectRatio)
        {
            // If the height is bigger then calculate the width to keep the viewport aspect ration
            minHeight = minWidth * (1.0 / aspectRatio);
        }
        else
        {
            // If the width is bigger that calculate the height to keep the viewport aspect ration
            minWidth = minHeight * aspectRatio;
        }
        
        // Calculate the distance from the viewplane the camera should be positioned
        var zDepth = Math.Cross(Real3(minWidth,0.0,0.0), Real3(0.0,minHeight,0.0));
        zDepth.Z = Math.Sqrt(zDepth.Z);
        
        // Constrain the zDepth to the min and max zoom levels
        zDepth.Z = Math.Clamp(zDepth.Z, this.MinZoom, this.MaxZoom);
        
        //Calculate the target camera position based of the requested average
        var targCamPos : Real3 = Real3();
        if (!this.ExtremaBasedTracking)
        {
            // Should weighted tracking be used
            if(this.WeightedTracking)
                targCamPos = avePosWeighted + zDepth;
            else
                targCamPos = avePos + zDepth;
        }
        else
        {
            targCamPos = Real3(leftMost.Transform.Translation.X + ((rightMost.Transform.Translation.X - leftMost.Transform.Translation.X)/2.0),
                               botMost.Transform.Translation.Y + ((topMost.Transform.Translation.Y - botMost.Transform.Translation.Y)/2.0), 
                               0.0) + zDepth;
        }
        
        // Should the new target focus position be the average position of all objects or just the axis extrema objects
        if(!this.ExtremaBaseFocusing)
        {
            if(this.WeightedFocusing)
            {
                // Interpolate the current focus position towards the weighted average position of all focus objects
                this.FocusPos = Math.Lerp(this.FocusPos, avePosWeighted, this.FocusSpeed * event.Dt);
            }
            else
            {
                // Interpolate the current focus position towards the average position of all focus objects
                this.FocusPos = Math.Lerp(this.FocusPos, avePos, this.FocusSpeed * event.Dt);
            }
        }
        else
        {
            // Interpolate the current focus position towards the average position of the axis extrema objects
            var targFocusPos : Real3 = Real3(leftMost.Transform.Translation.X + ((rightMost.Transform.Translation.X - leftMost.Transform.Translation.X)/2.0),
                               botMost.Transform.Translation.Y + ((topMost.Transform.Translation.Y - botMost.Transform.Translation.Y)/2.0), 
                               0.0);
            this.FocusPos = Math.Lerp(this.FocusPos, targFocusPos, this.FocusSpeed * event.Dt);
        }
        
        // Interpolate the camera towards the new tracking position
        if(this.Owner.Camera.PerspectiveMode == PerspectiveMode.Orthographic)
        {
            this.Owner.Camera.Size = Math.Lerp(this.Owner.Camera.Size, zDepth.Z, this.TrackingSpeed * event.Dt);
        }
        
        this.Owner.Transform.Translation = Math.Lerp(this.Owner.Transform.Translation, targCamPos, this.TrackingSpeed * event.Dt);
        
        // Turn the camera to look at the new focus point
        this.Owner.Orientation.LookAtPoint(this.FocusPos);
    }
    
    // Handles event request to add an object to the focus list
    function OnFocusCamera(event : CameraFocusEvent)
    {
        this.AddFocusObject(event.Object);
    }
    
    // Handles event request to remove an object to the focus list
    function OnUnfocusCamera(event : CameraUnfocusEvent)
    {
        this.RemoveFocusObject(event.Object);
    }
    
    // Confirms and then add an object to the focus list
    function AddFocusObject(object : Cog)
    {
        // Confirm it is a valid object
        if(object == null)
        {
            if(this.BreakOnError)
                throw new Exception("Attempting to focus camera on null object");
            
            return;
        }
        
        this.DebugOutput("Attempting to focus `object`");
        
        // confirm the weight is valid (if the weight is zero what is the point of including it in calculations
        if(object.CameraFocusTarget.FocusWeight == 0.0)
        {
            this.DebugOutput("Attempting to assign a camera focus object weight a weight of 0.0, causing it to not be considered in tracking for focusing");
        }
        
        var index = this.FocusList.FindFirstIndex(object);
        
        // If this object is already being focused
        if(index != -1)
        {
            this.DebugOutput("Attempting to add a duplicate object and weight to the focus list");
            
            return;
        }
        
        this.FocusList.Add(object);
        this.TotalWeight += object.CameraFocusTarget.FocusWeight;
        
        this.DebugOutput("Object added to Focus: `object` Weight: `object.CameraFocusTarget.FocusWeight`");
    }
    
    // Confirms and removes the given object from the focus list
    function RemoveFocusObject(object : Cog)
    {
        // Check if the object is valid
        if(object == null)
        {
            if(this.BreakOnError)
                throw new Exception("Attempting to remove null from camera focus list");
        }
        
        var index = this.FocusList.FindFirstIndex(object);
        
        // If the object is in the focus list
        if(index != -1)
        {
            // Remove the object
            this.FocusList.RemoveAt(index);
            
            this.TotalWeight -= object.CameraFocusTarget.FocusWeight;
        
            this.DebugOutput("Object removed from Focus: `object`");
        }
        else
        {
            if(this.BreakOnError)
                throw new Exception("Attempting to unfocus object that is not focused.");
        }
    }
    
    function DebugOutput(str : String)
    {
      if (this.DebugPrint)
        Console.WriteLine(str);
    }
}

// Used to request and object be added to the focus list with a valid weight
class CameraFocusEvent : ZilchEvent
{
    var Object : Cog = null;
    var Weight : Real
    {
        get
        {
            return this.Object.CameraFocusTarget.FocusWeight;
        }
    }
}

// Used to request and object be removed from the focus list
class CameraUnfocusEvent : ZilchEvent
{
    var Object : Cog = null;
}